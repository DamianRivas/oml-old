/*
 * The OML package specifies the abstract syntax (metamodel) of the Ontology Modeling Language using the [Ecore](https://www.eclipse.org/modeling/emf/) language.
 * Therefore, OML models are instances of this OML package and can be manipulated using the Java API induced by this package.     
 */
@Ecore(
	nsPrefix="oml",
	nsURI="http://opencaesar.io/Oml"
)
@GenModel(
    bundleManifest="false",
    modelDirectory="io.opencaesar.oml/build/xcore/main", 
    complianceLevel="8.0"
)
@BikeshedGroups(
	Common="",
	Literals="",
	Graphs="",
	Terms="",
	ClassTerms="",
	DataTerms="",
	Axioms="",
	Rules="",
	Instances="",
	Assertions="",
	References="",
	TerminologyReferences="",
	DescriptionReferences=""
)
@Bikeshed(
	heading="Abstract Syntax"
)
package io.opencaesar.oml

annotation "http://opencaesar.io/Oml" as Oml
annotation "https://tabatkins.github.io/bikeshed/" as Bikeshed
annotation "https://tabatkins.github.io/bikeshed/groups" as BikeshedGroups

/*
 * Element is the most abstract superclass of all objects in an OML model.
 */ 
@Bikeshed(subsection="Common")
abstract class Element {
}

/*
 * Annotation is an Element that provides a value for an AnnotationProperty placed on an [=AnnotatedElement=]. It does not have DL semantics.
 */
@Bikeshed(subsection="Common")
class Annotation extends Element {
	/*
	 * The annotation property that has the value
	 */
	refers AnnotationProperty[1] property
	/*
	 * The value of the annotation property
	 */
	contains LiteralValue[1] value
}

/*
 * AnnotatedElement is an Element that may have a set of Annotations.
 */
@Bikeshed(subsection="Common")
abstract class AnnotatedElement extends Element {
	/*
	 * The set of annotations on this element
	 */
	contains Annotation[] annotations
}

/*
 * NamedElement is an AnnotatedElement that has a name.
 */
@Bikeshed(subsection="Common")
abstract class NamedElement extends AnnotatedElement {
	/*
	 * The name of the element
	 */
	String[1] name
}

/*
 * Graph is a NamedElement that represents the root of containment in an OML model. The name of the graph is an alias to its base IRI. 
 */
@Bikeshed(subsection="Graphs")
abstract class Graph extends NamedElement {
	/*
	 * The base IRI representing the namespace of the graph 
	 */
	String[1] iri
}

/*
 * Terminology is a Graph that contains TerminologyStatements and may import other Terminologies.
 */
@Bikeshed(subsection="Graphs")
class Terminology extends Graph {
	/*
	 * The kind of terminology
	 */
	@Oml(annotationProperty="true")
	TerminologyKind kind
	/*
	 * The set of direct imports of other terminologies
	 */
	contains TerminologyImport[] imports
	/*
	 * The set of statements in the terminology
	 */
	contains TerminologyStatement[] statements
}

/*
 * TerminologyKind is an enumeration of the kinds of Terminology.
 */
@Bikeshed(subsection="Graphs")
enum TerminologyKind {
	/*
	 * Specifies that the terminology has open-world semantics
	 */
	Open as "open"
	/*
	 * Specifies that the terminology has closed-world semantics
	 */
	Closed as "closed" = 1
}

/*
 * Description is a Graph that contains DescriptionStatements and may import other Descriptions.
 */
@Bikeshed(subsection="Graphs")
class Description extends Graph {
	/*
	 * The kind of description
	 */
	@Oml(annotationProperty="true")
	DescriptionKind kind
	/*
	 * The set of direct imports of other descriptions
	 */
	contains DescriptionImport[] imports
	/*
	 * The set of statements in the description
	 */
	contains DescriptionStatement[] statements
}

/*
 * DescriptionKind is an enumeration of the kinds of Description.
 */
@Bikeshed(subsection="Graphs")
enum DescriptionKind {
	/*
	 * Specifies that the description is final, i.e., cannot be refined further 
	 */
	Final as "final"
	/*
	 * Specifies that the description is partial, i.e., is expected to be refined further 
	 */
	Partial as "partial" = 1
}

/*
 * GraphMember is a NamedElement that is a member of a [=Graph=].
 */
@Bikeshed(subsection="Graphs")
abstract class GraphMember extends NamedElement {
}

/*
 * TerminologyMember is a GraphMember that is a member of a [=Terminology=].
 */
@Bikeshed(subsection="Graphs")
abstract class TerminologyMember extends GraphMember {
}

/*
 * Term is a TerminologyMember and TerminologyStatement that is defined by a [=Terminology=] and can be specialized in a hierarchy.
 */
@Bikeshed(subsection="Terms")
abstract class Term extends TerminologyMember, TerminologyStatement {
	/*
	 * The set of specializations of the term
	 */
	contains TermSpecializationAxiom[] specializations
}

/*
 * CharacterizableTerm is a Term that can be characterized by properties.
 */
@Bikeshed(subsection="Terms")
abstract class CharacterizableTerm extends Term {
}

/*
 * Entity is a CharacterizableTerm that can be interrelated and restricted.
 */
@Bikeshed(subsection="ClassTerms")
abstract class Entity extends CharacterizableTerm {
	/*
	 * The set of restriction axioms on the Entity's properties
	 */
	contains EntityRestrictionAxiom[] restrictions
}

/*
 * Aspect is an Entity that defines cross-cutting characterizations that can be mixed with those of other Entities.
 */
@Bikeshed(subsection="ClassTerms")
class Aspect extends Entity {
}

/*
 * Concept is an Entity that represents a concrete class of objects or ideas.
 */
@Bikeshed(subsection="ClassTerms")
class Concept extends Entity {
}

/*
 * ReifiedRelationship is a Relationship that is also reified as an Entity, i.e., can be characterized and interrelated.
 */
@Bikeshed(subsection="ClassTerms")
@Oml(reifiedRelationship="true", forward="reifiedRelationshipForward", inverse="reifiedRelationshipInverse")
class ReifiedRelationship extends Entity , Relationship {
}

/*
 * Structure is a CharacterizableTerm that can be specified by value (i.e., cannot be referenced).
 */
@Bikeshed(subsection="DataTerms")
class Structure extends CharacterizableTerm {
}

/*
 * Relationship is a Term that represents a relationship from a source Term to a target Term.
 */
@Bikeshed(subsection="ClassTerms")
abstract class Relationship extends Term {
	/*
	 * The source Term of the Relationship
	 */
	@Oml(source="true")
	refers Entity[1] source
	/*
	 * The target Term of the Relationship
	 */
	@Oml(target="true")
	refers Entity[1] target
	/*
	 * The forward direction of the relationship
	 */
	@Oml(ignore="true")
	contains ForwardDirection[1] forward
	/*
	 * The inverse direction of the relationship
	 */
	@Oml(ignore="true")
	contains InverseDirection inverse
	/*
	 * Whether the Relationship is functional (A->B and A->C => B=C)
	 */
	boolean functional
	/*
	 * Whether the Relationship is inverse functional (B->A and C->A => B=C)
	 */
	boolean inverseFunctional
	/*
	 * Whether the Relationship is symmetric (A->B => B->A)
	 */
	boolean symmetric
	/*
	 * Whether the Relationship is asymmetric (A->B => B!->A)
	 */
	boolean asymmetric
	/*
	 * Whether the Relationship is reflexive (A => A->A)
	 */
	boolean reflexive
	/*
	 * Whether the Relationship is reflexive (A => A!->A)
	 */
	boolean irreflexive
	/*
	 * Whether the Relationship is reflexive (A->B and B->C => A->C)
	 */
	boolean transitive
}

/*
 * UnreifiedRelationship is a Relationship that is not reified but represents a simple reference
 */
@Bikeshed(subsection="ClassTerms")
@Oml(reifiedRelationship="true", forward="unreifiedRelationshipForward", inverse="unreifiedRelationshipInverse")
class UnreifiedRelationship extends Relationship {
}

/*
 * ScalarRange is a Term that represents the abstract superclass of all ScalarRanges.
 */
@Bikeshed(subsection="DataTerms")
abstract class ScalarRange extends Term {
}

/*
 * Scalar is a ScalarRange that does not specialize other ScalarRanges.
 */
@Bikeshed(subsection="DataTerms")
class Scalar extends ScalarRange {
}

/*
 * CharArrayScalar is a ScalarRange that specializes another ScalarRange, whose literals are represented as character arrays,
 * and may restrict some facets of those arrays.
 */
@Bikeshed(subsection="DataTerms")
abstract class CharArrayScalar extends ScalarRange {
	/*
	 * The exact length of the character array 
	 */
	Integer length
	/*
	 * The minimum length of the character array 
	 */
	Integer minLength
	/*
	 * The maximum length of the character array 
	 */
	Integer maxLength
}

/*
 * BinaryScalar is a CharArrayScalar whose literals represent binary numbers, i.e., arrays of 0 and 1 digits.
 */
@Bikeshed(subsection="DataTerms")
class BinaryScalar extends CharArrayScalar {
}

/*
 * PatternScalar is a CharArrayScalar whose literals lexically conform to a pattern specified by a regex expression.
 */
@Bikeshed(subsection="DataTerms")
abstract class PatternScalar extends CharArrayScalar {
	/*
	 * The regex expression of the pattern
	 */
	String pattern
}

/*
 * IRIScalar is a PatternScalar whose literals represent IRIs.
 */
@Bikeshed(subsection="DataTerms")
class IRIScalar extends PatternScalar {
}

/*
 * PlainLiteralScalar is a PatternScalar whose literals belong to a given language.
 */
@Bikeshed(subsection="DataTerms")
class PlainLiteralScalar extends PatternScalar {
	/*
	 * The tag of the language of the literals. See this [reference](https://www.w3.org/TR/2012/REC-rdf-plain-literal-20121211/) for more details.
	 */
	String language
}

/*
 * StringScalar is a PatternScalar whose literals represent arbitrary string values.
 */
@Bikeshed(subsection="DataTerms")
class StringScalar extends PatternScalar {
}

/*
 * NumericScalar is a ScalarRange that specializes another ScalarRange, whose literals represent a numeric range,
 * and may restrict some facets of that range.
 */
@Bikeshed(subsection="DataTerms")
class NumericScalar extends ScalarRange {
	/*
	 * The minimum inclusive value of the numeric range
	 */
	contains LiteralNumber minInclusive
	/*
	 * The minimum exclusive value of the numeric range
	 */
	contains LiteralNumber minExclusive
	/*
	 * The maximum inclusive value of the numeric range
	 */
	contains LiteralNumber maxInclusive
	/*
	 * The maximum exclusive value of the numeric range
	 */
	contains LiteralNumber maxExclusive
}

/*
 * TimeScalar is a ScalarRange that specializes another ScalarRange, whose literals represent time range,
 * and may restrict some facets of that range.
 */
@Bikeshed(subsection="DataTerms")
class TimeScalar extends ScalarRange {
	/*
	 * The minimum inclusive value of the time range
	 */
	contains LiteralDateTime minInclusive
	/*
	 * The minimum exclusive value of the time range
	 */
	contains LiteralDateTime minExclusive
	/*
	 * The maximum inclusive value of the time range
	 */
	contains LiteralDateTime maxInclusive
	/*
	 * The maximum exclusive value of the time range
	 */
	contains LiteralDateTime maxExclusive
}

/*
 * EnumerationScalar is a ScalarRange whose literals are enumerated and cannot specialize other ScalarRanges.
 */
@Bikeshed(subsection="DataTerms")
class EnumerationScalar extends ScalarRange {
	/*
	 * The set of valid enumerated literals
	 */
	contains LiteralValue[] literals
}

@Bikeshed(subsection="Terms")
abstract class Property extends Term {
}

@Bikeshed(subsection="Terms")
abstract class CharacterizationProperty extends Property {
	refers CharacterizableTerm[1] domain
	boolean functional
}

@Bikeshed(subsection="Terms")
class StructuredProperty extends CharacterizationProperty {
	refers Structure[1] range
}

@Bikeshed(subsection="Terms")
class ScalarProperty extends CharacterizationProperty {
	refers ScalarRange[1] range
}

@Bikeshed(subsection="Terms")
class AnnotationProperty extends Property {
}

@Bikeshed(subsection="Rules")
class Rule extends TerminologyMember, TerminologyStatement {
	contains Predicate[1..*] antecedent
	contains DirectionalRelationshipPredicate[1] consequent
}

@Bikeshed(subsection="ClassTerms")
abstract class RelationshipDirection extends TerminologyMember {
}

@Bikeshed(subsection="ClassTerms")
@Oml(ignore="true")
class ForwardDirection extends RelationshipDirection {
}

@Bikeshed(subsection="ClassTerms")
@Oml(ignore="true")
class InverseDirection extends RelationshipDirection {
}

@Bikeshed(subsection="Graphs")
abstract class DescriptionMember extends GraphMember, DescriptionStatement {
}

@Bikeshed(subsection="Instances")
abstract class NamedInstance extends DescriptionMember , Instance {
}

@Bikeshed(subsection="Instances")
class ConceptInstance extends NamedInstance {
	contains Assertion[] types
}

@Bikeshed(subsection="Instances")
class ReifiedRelationshipInstance extends NamedInstance {
	contains ReifiedRelationshipInstanceTypeAssertion[] types
	refers NamedInstance[1] source
	refers NamedInstance[1] target
}

@Bikeshed(subsection="References")
abstract class NamedElementReference extends AnnotatedElement {
}

@Bikeshed(subsection="References")
abstract class GraphMemberReference extends NamedElementReference {
}

@Bikeshed(subsection="TerminologyReferences")
abstract class TerminologyMemberReference extends GraphMemberReference, TerminologyStatement {
}

@Bikeshed(subsection="TerminologyReferences")
abstract class TermReference extends TerminologyMemberReference {
	contains TermSpecializationAxiom[] specializations
}

@Bikeshed(subsection="TerminologyReferences")
abstract class EntityReference extends TermReference {
	contains EntityRestrictionAxiom[] restrictions
}

@Bikeshed(subsection="TerminologyReferences")
class AspectReference extends EntityReference {
	refers Aspect[1] aspect
}

@Bikeshed(subsection="TerminologyReferences")
class ConceptReference extends EntityReference {
	refers Concept[1] concept
}

@Bikeshed(subsection="TerminologyReferences")
class ReifiedRelationshipReference extends EntityReference {
	refers ReifiedRelationship[1] relationship
}

@Bikeshed(subsection="TerminologyReferences")
class UnreifiedRelationshipReference extends TermReference {
	refers UnreifiedRelationship[1] relationship
}

@Bikeshed(subsection="TerminologyReferences")
class StructureReference extends TermReference {
	refers Structure[1] structure
}

@Bikeshed(subsection="TerminologyReferences")
class ScalarRangeReference extends TermReference {
	refers ScalarRange[1] scalar
}

@Bikeshed(subsection="TerminologyReferences")
class StructuredPropertyReference extends TermReference {
	refers StructuredProperty[1] property
}

@Bikeshed(subsection="TerminologyReferences")
class ScalarPropertyReference extends TermReference {
	refers ScalarProperty[1] property
}

@Bikeshed(subsection="TerminologyReferences")
class RelationshipDirectionReference extends TerminologyMemberReference {
	refers RelationshipDirection[1] direction
}

@Bikeshed(subsection="TerminologyReferences")
class RuleReference extends TerminologyMemberReference {
	refers Rule[1] rule	
}

@Bikeshed(subsection="DescriptionReferences")
abstract class DescriptionMemberReference extends GraphMemberReference, DescriptionStatement {
}

@Bikeshed(subsection="DescriptionReferences")
abstract class NamedInstanceReference extends DescriptionMemberReference {
	contains InstancePropertyValueAssertion[] propertyValues
}

@Bikeshed(subsection="DescriptionReferences")
class ConceptInstanceReference extends NamedInstanceReference {
	refers ConceptInstance[1] instance
	contains ConceptInstanceTypeAssertion[] types
}

@Bikeshed(subsection="DescriptionReferences")
class ReifiedRelationshipInstanceReference extends NamedInstanceReference {
	refers ReifiedRelationshipInstance[1] instance
	contains ReifiedRelationshipInstanceTypeAssertion[] types
}

@Bikeshed(subsection="Graphs")
abstract class GraphStatement extends AnnotatedElement {
}

@Bikeshed(subsection="Graphs")
abstract class TerminologyStatement extends GraphStatement {
}

@Bikeshed(subsection="Graphs")
abstract class DescriptionStatement extends GraphStatement {
}

@Bikeshed(subsection="Axioms")
abstract class Axiom extends AnnotatedElement {
}

@Bikeshed(subsection="Axioms")
class TermSpecializationAxiom extends Axiom {
	refers Term[1] specializedTerm
}

@Bikeshed(subsection="Axioms")
abstract class EntityRestrictionAxiom extends Axiom {
}

@Bikeshed(subsection="Axioms")
abstract class RelationshipRestrictionAxiom extends EntityRestrictionAxiom {
	refers RelationshipDirection[1] relationshipDirection
	refers Entity[1] restrictedTo
}

@Bikeshed(subsection="Axioms")
class ExistentialRelationshipRestrictionAxiom extends RelationshipRestrictionAxiom {
}

@Bikeshed(subsection="Axioms")
class UniversalRelationshipRestrictionAxiom extends RelationshipRestrictionAxiom {
}

@Bikeshed(subsection="Axioms")
abstract class ScalarPropertyRestrictionAxiom extends EntityRestrictionAxiom {
	refers ScalarProperty[1] property
}

@Bikeshed(subsection="Axioms")
abstract class TypedScalarPropertyRestrictionAxion extends ScalarPropertyRestrictionAxiom {
	refers ScalarRange[1] restrictedTo
}

@Bikeshed(subsection="Axioms")
class ExistentialScalarPropertyRestrictionAxiom extends TypedScalarPropertyRestrictionAxion {
}

@Bikeshed(subsection="Axioms")
class UniversalScalarPropertyRestrictionAxiom extends TypedScalarPropertyRestrictionAxion {
}

@Bikeshed(subsection="Axioms")
class ParticularScalarPropertyRestrictionAxiom extends ScalarPropertyRestrictionAxiom {
	contains LiteralValue[1] value
}

@Bikeshed(subsection="Axioms")
class StructuredPropertyRestrictionAxiom extends EntityRestrictionAxiom {
	refers StructuredProperty[1] property
	contains StructureInstance[1] value
}

@Bikeshed(subsection="Assertions")
abstract class Assertion extends AnnotatedElement {
}

@Bikeshed(subsection="Assertions")
class ConceptInstanceTypeAssertion extends Assertion {
	refers Concept[1] concept	
}

@Bikeshed(subsection="Assertions")
class ReifiedRelationshipInstanceTypeAssertion extends Assertion {
	refers ReifiedRelationship[1] relationship	
}

@Bikeshed(subsection="Assertions")
abstract class InstancePropertyValueAssertion extends Assertion {
}

@Bikeshed(subsection="Assertions")
class ScalarPropertyValueAssertion extends InstancePropertyValueAssertion {
	refers ScalarProperty[1] property
	contains LiteralValue[1] value
}

@Bikeshed(subsection="Assertions")
class StructuredPropertyValueAssertion extends InstancePropertyValueAssertion {
	refers StructuredProperty[1] property
	contains StructureInstance[1] value
}

@Bikeshed(subsection="Graphs")
abstract class GraphImport extends Element {
	String[1] importURI
	String importedNamespace
}

@Bikeshed(subsection="Graphs")
abstract class TerminologyImport extends GraphImport {
}

@Bikeshed(subsection="Graphs")
class TerminologyExtension extends TerminologyImport {
}

@Bikeshed(subsection="Graphs")
abstract class DescriptionImport extends GraphImport {
}

@Bikeshed(subsection="Graphs")
class DescriptionUsage extends DescriptionImport {
}

@Bikeshed(subsection="Graphs")
class DescriptionRefinement extends DescriptionImport {
}

@Bikeshed(subsection="Instances")
abstract class Instance extends Element {
	contains InstancePropertyValueAssertion[] propertyValues
}

@Bikeshed(subsection="Instances")
class StructureInstance extends Instance {
	refers Structure[1] structure
}

@Bikeshed(subsection="Literals")
abstract class LiteralValue extends Element {
	refers ScalarRange valueType
}

@Bikeshed(subsection="Literals")
class LiteralBoolean extends LiteralValue {
	boolean value
}

@Bikeshed(subsection="Literals")
class LiteralDateTime extends LiteralValue {
	String[1] value
}

@Bikeshed(subsection="Literals")
class LiteralString extends LiteralValue {
	String[1] value
}

@Bikeshed(subsection="Literals")
class LiteralUUID extends LiteralValue {
	String[1] value
}

@Bikeshed(subsection="Literals")
class LiteralURI extends LiteralValue {
	String[1] value
}

@Bikeshed(subsection="Literals")
abstract class LiteralNumber extends LiteralValue {
}

@Bikeshed(subsection="Literals")
class LiteralReal extends LiteralNumber {
	Double[1] value
}

@Bikeshed(subsection="Literals")
class LiteralRational extends LiteralNumber {
	Double[1] value
}

@Bikeshed(subsection="Literals")
class LiteralFloat extends LiteralNumber {
	Float[1] value
}

@Bikeshed(subsection="Literals")
class LiteralDecimal extends LiteralNumber {
	BigDecimal[1] value
}

@Bikeshed(subsection="Rules")
abstract class Predicate extends Element {
}

@Bikeshed(subsection="Rules")
class EntityPredicate extends Predicate {
	refers Entity[1] entity
	String[1] variable
}

@Bikeshed(subsection="Rules")
abstract class RelationshipPredicate extends Predicate {
	String[1] variable1
	String[1] variable2
}

@Bikeshed(subsection="Rules")
class DirectionalRelationshipPredicate extends RelationshipPredicate {
	refers RelationshipDirection[1] relationshipDirection
}

@Bikeshed(subsection="Rules")
class ReifiedRelationshipPredicate extends RelationshipPredicate {
	refers ReifiedRelationship[1] relationship
	ReifiedRelationshipPredicateKind kind
}

@Bikeshed(subsection="Rules")
enum ReifiedRelationshipPredicateKind {
	Source as "source"
	InverseSource as "inverseSource" = 1
	Target as "target" = 2
	InverseTarget as "inverseTarget" = 3
}

